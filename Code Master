#include "ESP32_NOW.h"
#include "WiFi.h"
#include <esp_mac.h>  // Für die MAC2STR und MACSTR Makros
#include <SPI.h>

#define ESPNOW_WIFI_CHANNEL 6
#define CAN_2515

// Setze SPI CS Pin je nach Hardware
const int SPI_CS_PIN = 9;
const int CAN_INT_PIN = 2;

#ifdef CAN_2515
#include "mcp2515_can.h"
mcp2515_can CAN(SPI_CS_PIN); // Setze CS Pin
#define MAX_DATA_SIZE 8
#endif

/* Klassen */
typedef struct Data {
  int Tank;
  int Schiebedach;
  char data_tank_hex[MAX_DATA_SIZE * 2 + 1]; // Hex-Daten als String
} Data;

Data BME280Readings;

int Tankfüllstand;
int SchiebedachProzent;

uint32_t id;
uint8_t type; // bit0: ext, bit1: rtr
uint8_t len;
byte cdata[MAX_DATA_SIZE] = {0};

// Erstellen einer neuen Klasse, die von der ESP_NOW_Peer-Klasse erbt
class ESP_NOW_Broadcast_Peer : public ESP_NOW_Peer {
public:
  ESP_NOW_Broadcast_Peer(uint8_t channel, wifi_interface_t iface, const uint8_t *lmk)
    : ESP_NOW_Peer(ESP_NOW.BROADCAST_ADDR, channel, iface, lmk) {}

  ~ESP_NOW_Broadcast_Peer() {
    remove();
  }

  bool begin() {
    if (!ESP_NOW.begin() || !add()) {
      log_e("Failed to initialize ESP-NOW or register the broadcast peer");
      return false;
    }
    return true;
  }

  bool send_message(const uint8_t *data, size_t len) {
    if (!send(data, len)) {
      log_e("Failed to broadcast message");
      return false;
    }
    return true;
  }
};

/* Globale Variablen */
uint32_t msg_count = 0;
ESP_NOW_Broadcast_Peer broadcast_peer(ESPNOW_WIFI_CHANNEL, WIFI_IF_STA, NULL);

/* Hauptprogramm */
void setup() {
  Serial.begin(115200);

  while (!Serial) {
    delay(10);
  }

  while (CAN_OK != CAN.begin(CAN_250KBPS)) {
    Serial.println(F("CAN init fail, retry..."));
    delay(100);
  }
  Serial.println(F("CAN init ok!"));

  WiFi.mode(WIFI_STA);
  WiFi.setChannel(ESPNOW_WIFI_CHANNEL);
  while (!WiFi.STA.started()) {
    delay(100);
  }

  Serial.println("ESP-NOW Example - Broadcast Master");
  Serial.println("Wi-Fi parameters:");
  Serial.println("  Mode: STA");
  Serial.println("  MAC Address: " + WiFi.macAddress());
  Serial.printf("  Channel: %d\n", ESPNOW_WIFI_CHANNEL);

  if (!broadcast_peer.begin()) {
    Serial.println("Failed to initialize broadcast peer");
    Serial.println("Rebooting in 5 seconds...");
    delay(5000);
    ESP.restart();
  }

  Serial.println("Setup complete. Broadcasting messages every 5 seconds.");
}

void loop() {
  // Prüfen, ob Daten verfügbar sind
  if (CAN_MSGAVAIL != CAN.checkReceive()) {
    return;
  }

  // Daten lesen, len: Datenlänge, cdata: Datenpuffer
  CAN.readMsgBuf(&len, cdata);
  id = CAN.getCanId();

  // Spezifische CAN-ID prüfen
  if (id == 0x42E) {
    Serial.print("Data Field: ");
    for (int i = 0; i < len; i++) {
      Serial.print(cdata[i], HEX);
      Serial.print(" ");
      sprintf(BME280Readings.data_tank_hex + 2 * i, "%02X", cdata[i]);
    }
    Serial.println();

    // Hex-Daten in Dezimal umwandeln
    Tankfüllstand = hexToDec(BME280Readings.data_tank_hex);

    // Nachricht erstellen und senden
    char data[32];
    snprintf(data, sizeof(data), "Tank: %d", Tankfüllstand);
    Serial.printf("Broadcasting message: %s\n", data);

    if (!broadcast_peer.send_message((uint8_t *)data, sizeof(data))) {
      Serial.println("Failed to broadcast message");
    }
  }

  delay(5000);
}

unsigned long hexToDec(char* hexStr) {
  int len = strlen(hexStr);
  unsigned long result = 0;
  int index = 0;

  for (int i = len - 1; i >= 0; i--) {
    int value = charToHex(hexStr[i]);
    result += value * pow(16, index);
    index++;
  }

  return result;
}

int charToHex(char c) {
  if (c >= '0' && c <= '9') {
    return c - '0';
  } else if (c >= 'A' && c <= 'F') {
    return c - 'A' + 10;
  } else if (c >= 'a' && c <= 'f') {
    return c - 'a' + 10;
  } else {
    return 0;
  }
}
